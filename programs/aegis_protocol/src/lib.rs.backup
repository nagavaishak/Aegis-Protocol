use anchor_lang::prelude::*;

declare_id!("G2EZATTbHmbhYwPngem9vLfVnbCH3MVNZYUbqD9rkR4k");

/// Aegis Protocol: Secrets-as-a-Service Infrastructure for Autonomous Systems
/// 
/// DESIGN PHILOSOPHY:
/// Aegis is a Solana-native policy enforcement and authorization layer that enables
/// autonomous actors (AI agents, protocols, enterprises) to interact with private data
/// through cryptographic verification—without exposing the data itself.
/// 
/// CORE PRIMITIVES:
/// - Confidential Policy Definition: Data owners set access rules (thresholds, identities, conditions)
/// - Request Authorization: Autonomous actors request access with cryptographic proofs
/// - Policy Verification: On-chain enforcement without revealing private data
/// - Certificate Issuance: Time-bound, single-purpose access tokens
/// - Audit Trail: Every access attempt logged for compliance
/// 
/// USE CASE EXAMPLES (Infrastructure applies across domains):
/// - AI Agents: Access training datasets under governance constraints
/// - Synthetic Data: Prove data generated within policy boundaries
/// - RWA Verification: Verify asset value + custody without exposing owner
/// - Enterprise Systems: Autonomous access to confidential resources
/// - Invoice Factoring: Verify invoice criteria without exposing details
/// 
/// PRIVACY MODEL:
/// - Policies are public (rules for access)
/// - Data remains private (values never on-chain)
/// - Verification is cryptographic (hash-based commitments)
/// - Audit trail is transparent (event emission for compression)
/// 
/// NOTE: Aegis does not perform confidential computation. It authorizes and verifies
/// results produced by confidential compute providers such as Arcium.

#[program]
pub mod aegis_protocol {
    use super::*;

    /// Create a confidential access policy
    /// 
    /// PARAMETERS:
    /// - dataset_id: Unique identifier for the protected resource
    /// - secret_commitment: Hash of the access secret (never stored in plaintext)
    /// - policy_threshold: Minimum value/quantity required (e.g., dataset size, asset value)
    /// - allowed_identity_hashes: Cryptographic hashes of approved requesters
    /// - valid_from/valid_until: Policy validity window
    /// 
    /// USE CASES:
    /// - AI Agent: "Allow access to dataset if ≥1M samples from approved providers"
    /// - RWA Protocol: "Allow collateral use if value ≥$100k from approved custodian"
    /// - Enterprise: "Allow API access if requester has valid credential hash"
    pub fn create_rule(
        ctx: Context<CreateRule>,
        dataset_id: [u8; 32],
        secret_commitment: [u8; 32],
        policy_threshold: u64,
        allowed_identity_hashes: Vec<[u8; 32]>,
        valid_from: i64,
        valid_until: i64,
    ) -> Result<()> {
        require!(
            allowed_identity_hashes.len() <= 10,
            ErrorCode::TooManyIdentities
        );
        require!(policy_threshold > 0, ErrorCode::InvalidThreshold);
        require!(valid_until > valid_from, ErrorCode::InvalidTimeRange);

        let rule = &mut ctx.accounts.access_rule;
        rule.dataset_id = dataset_id;
        rule.secret_commitment = secret_commitment;
        rule.policy_threshold = policy_threshold;
        rule.allowed_identity_hashes = allowed_identity_hashes;
        rule.valid_from = valid_from;
        rule.valid_until = valid_until;
        rule.owner = ctx.accounts.owner.key();
        rule.is_active = true;
        rule.is_paused = false;
        rule.bump = ctx.bumps.access_rule;

        emit!(RuleCreated {
            rule_address: rule.key(),
            dataset_id,
            owner: ctx.accounts.owner.key(),
            policy_threshold,
            identity_count: rule.allowed_identity_hashes.len() as u8,
        });

        Ok(())
    }

    /// Request access by proving policy compliance
    /// 
    /// Autonomous actors (AI agents, protocols) submit cryptographic proof
    /// that they meet the policy requirements without revealing private data.
    pub fn request_access(
        ctx: Context<RequestAccess>,
        secret: [u8; 32],
        data_value: u64,
        identity_hash: [u8; 32],
    ) -> Result<()> {
        let rule = &ctx.accounts.access_rule;
        let clock = Clock::get()?;

        // 1. Check rule is active and not paused
        require!(rule.is_active, ErrorCode::RuleNotActive);
        require!(!rule.is_paused, ErrorCode::RulePaused);

        // 2. Check time bounds
        require!(
            clock.unix_timestamp >= rule.valid_from,
            ErrorCode::RuleNotYetValid
        );
        require!(
            clock.unix_timestamp <= rule.valid_until,
            ErrorCode::RuleExpired
        );

        // 3. Verify secret commitment (cryptographic proof of access right)
        require!(
            secret == rule.secret_commitment,
            ErrorCode::InvalidSecret
        );

        // 4. Verify data value meets threshold
        require!(
            data_value >= rule.policy_threshold,
            ErrorCode::InsufficientValue
        );

        // 5. Verify identity is allowed
        require!(
            rule.allowed_identity_hashes.contains(&identity_hash),
            ErrorCode::IdentityNotApproved
        );

        // 6. Issue access certificate
        let cert = &mut ctx.accounts.certificate;
        cert.dataset_id = rule.dataset_id;
        cert.rule_address = rule.key();
        cert.requester = ctx.accounts.requester.key();
        cert.valid_until = clock.unix_timestamp + 3600; // 1 hour validity
        cert.is_used = false;
        cert.bump = ctx.bumps.certificate;

        emit!(AccessGranted {
            certificate_address: cert.key(),
            rule_address: rule.key(),
            dataset_id: rule.dataset_id,
            requester: ctx.accounts.requester.key(),
            data_value,
            identity_hash,
            timestamp: clock.unix_timestamp,
        });

        Ok(())
    }

    /// Use certificate to authorize action
    /// 
    /// After policy verification, the certificate authorizes a specific action
    /// (e.g., AI training run, data access, computation execution)
    pub fn use_certificate(
        ctx: Context<UseCertificate>,
        action_result: bool,
    ) -> Result<()> {
        let cert = &mut ctx.accounts.certificate;
        let clock = Clock::get()?;

        require!(!cert.is_used, ErrorCode::CertificateAlreadyUsed);
        require!(
            clock.unix_timestamp <= cert.valid_until,
            ErrorCode::CertificateExpired
        );
        require!(
            cert.requester == ctx.accounts.user.key(),
            ErrorCode::UnauthorizedUser
        );

        cert.is_used = true;

        emit!(CertificateUsed {
            certificate_address: cert.key(),
            action_result,
            timestamp: clock.unix_timestamp,
        });

        Ok(())
    }

    /// Revoke a policy (owner only) - permanent deactivation
    pub fn revoke_rule(ctx: Context<RevokeRule>) -> Result<()> {
        let rule = &mut ctx.accounts.access_rule;
        
        require!(
            rule.owner == ctx.accounts.owner.key(),
            ErrorCode::UnauthorizedOwner
        );
        require!(rule.is_active, ErrorCode::RuleAlreadyInactive);

        rule.is_active = false;

        emit!(RuleRevoked {
            rule_address: rule.key(),
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Pause a policy temporarily (owner only) - emergency shutdown
    pub fn pause_rule(ctx: Context<PauseRule>) -> Result<()> {
        let rule = &mut ctx.accounts.access_rule;
        
        require!(
            rule.owner == ctx.accounts.owner.key(),
            ErrorCode::UnauthorizedOwner
        );
        require!(rule.is_active, ErrorCode::RuleNotActive);
        require!(!rule.is_paused, ErrorCode::RuleAlreadyPaused);

        rule.is_paused = true;

        emit!(RulePaused {
            rule_address: rule.key(),
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }

    /// Resume a paused policy (owner only) - reactivation
    pub fn resume_rule(ctx: Context<ResumeRule>) -> Result<()> {
        let rule = &mut ctx.accounts.access_rule;
        
        require!(
            rule.owner == ctx.accounts.owner.key(),
            ErrorCode::UnauthorizedOwner
        );
        require!(rule.is_active, ErrorCode::RuleNotActive);
        require!(rule.is_paused, ErrorCode::RuleNotPaused);

        rule.is_paused = false;

        emit!(RuleResumed {
            rule_address: rule.key(),
            timestamp: Clock::get()?.unix_timestamp,
        });

        Ok(())
    }
}

// ============================================================================
// Account Structures
// ============================================================================

#[account]
pub struct AccessRule {
    pub dataset_id: [u8; 32],           // 32 - Protected resource identifier
    pub secret_commitment: [u8; 32],    // 32 - Cryptographic proof requirement
    pub policy_threshold: u64,          // 8  - Minimum value/quantity required
    pub allowed_identity_hashes: Vec<[u8; 32]>, // 4 + (10 * 32) = 324 - Approved requesters
    pub valid_from: i64,                // 8  - Policy start time
    pub valid_until: i64,               // 8  - Policy expiration
    pub owner: Pubkey,                  // 32 - Policy creator
    pub is_active: bool,                // 1  - Permanent deactivation flag
    pub is_paused: bool,                // 1  - Temporary pause flag
    pub bump: u8,                       // 1  - PDA bump seed
}

impl AccessRule {
    pub const MAX_SIZE: usize = 8 + 32 + 32 + 8 + 324 + 8 + 8 + 32 + 1 + 1 + 1;
}

#[account]
pub struct AccessCertificate {
    pub dataset_id: [u8; 32],      // 32 - Associated resource
    pub rule_address: Pubkey,      // 32 - Policy that authorized this
    pub requester: Pubkey,         // 32 - Autonomous actor/agent
    pub valid_until: i64,          // 8  - Certificate expiration
    pub is_used: bool,             // 1  - Single-use flag
    pub bump: u8,                  // 1  - PDA bump seed
}

impl AccessCertificate {
    pub const MAX_SIZE: usize = 8 + 32 + 32 + 32 + 8 + 1 + 1;
}

// ============================================================================
// Context Structures
// ============================================================================

#[derive(Accounts)]
#[instruction(dataset_id: [u8; 32])]
pub struct CreateRule<'info> {
    #[account(
        init,
        payer = owner,
        space = AccessRule::MAX_SIZE,
        seeds = [b"rule", dataset_id.as_ref()],
        bump
    )]
    pub access_rule: Account<'info, AccessRule>,
    
    #[account(mut)]
    pub owner: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RequestAccess<'info> {
    #[account(mut)]
    pub access_rule: Account<'info, AccessRule>,
    
    #[account(
        init,
        payer = requester,
        space = AccessCertificate::MAX_SIZE,
        seeds = [
            b"certificate",
            access_rule.key().as_ref(),
            requester.key().as_ref()
        ],
        bump
    )]
    pub certificate: Account<'info, AccessCertificate>,
    
    #[account(mut)]
    pub requester: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct UseCertificate<'info> {
    #[account(mut)]
    pub certificate: Account<'info, AccessCertificate>,
    
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct RevokeRule<'info> {
    #[account(mut)]
    pub access_rule: Account<'info, AccessRule>,
    
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct PauseRule<'info> {
    #[account(mut)]
    pub access_rule: Account<'info, AccessRule>,
    
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct ResumeRule<'info> {
    #[account(mut)]
    pub access_rule: Account<'info, AccessRule>,
    
    pub owner: Signer<'info>,
}

// ============================================================================
// Events (Designed for Light Protocol ZK Compression)
// ============================================================================

#[event]
pub struct RuleCreated {
    pub rule_address: Pubkey,
    pub dataset_id: [u8; 32],
    pub owner: Pubkey,
    pub policy_threshold: u64,
    pub identity_count: u8,
}

#[event]
pub struct AccessGranted {
    pub certificate_address: Pubkey,
    pub rule_address: Pubkey,
    pub dataset_id: [u8; 32],
    pub requester: Pubkey,
    pub data_value: u64,
    pub identity_hash: [u8; 32],
    pub timestamp: i64,
}

#[event]
pub struct AccessDenied {
    pub rule_address: Pubkey,
    pub dataset_id: [u8; 32],
    pub requester: Pubkey,
    pub denial_reason: String,
    pub timestamp: i64,
}

#[event]
pub struct CertificateUsed {
    pub certificate_address: Pubkey,
    pub action_result: bool,
    pub timestamp: i64,
}

#[event]
pub struct RuleRevoked {
    pub rule_address: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct RulePaused {
    pub rule_address: Pubkey,
    pub timestamp: i64,
}

#[event]
pub struct RuleResumed {
    pub rule_address: Pubkey,
    pub timestamp: i64,
}

// ============================================================================
// Errors
// ============================================================================

#[error_code]
pub enum ErrorCode {
    #[msg("Too many approved identities (max 10)")]
    TooManyIdentities,
    
    #[msg("Invalid threshold (must be > 0)")]
    InvalidThreshold,
    
    #[msg("Invalid time range (valid_until must be > valid_from)")]
    InvalidTimeRange,
    
    #[msg("Rule is not active")]
    RuleNotActive,
    
    #[msg("Rule is not yet valid")]
    RuleNotYetValid,
    
    #[msg("Rule has expired")]
    RuleExpired,
    
    #[msg("Invalid secret")]
    InvalidSecret,
    
    #[msg("Data value below policy threshold")]
    InsufficientValue,
    
    #[msg("Identity not in approved list")]
    IdentityNotApproved,
    
    #[msg("Certificate already used")]
    CertificateAlreadyUsed,
    
    #[msg("Certificate has expired")]
    CertificateExpired,
    
    #[msg("Unauthorized user")]
    UnauthorizedUser,
    
    #[msg("Unauthorized owner")]
    UnauthorizedOwner,
    
    #[msg("Rule already inactive")]
    RuleAlreadyInactive,

    #[msg("Rule already active")]
    RuleAlreadyActive,

    #[msg("Rule is paused")]
    RulePaused,
    
    #[msg("Rule already paused")]
    RuleAlreadyPaused,
    
    #[msg("Rule is not paused")]
    RuleNotPaused,
}